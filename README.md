# Задача "Тайный Шифр", 091

---
В огромном тексте содержится тайный шифр. Чтобы его прочитать, необходимо взять слово-ключ (которое может быть самым разным, но не превышает по длине пяти букв) и найти последовательность из нескольких слов таких, что первая буква первого слова, вторая -- второго, третья -- третьего и так далее будут образовывать слово-ключ. Номер первого слова необходимо вывести.

Реализуйте структуру, которая принимает текст, обрабатывает его, а потом эффективно отвечает на запросы, возвращая номер первого слова по ключу. Слова разделены пробелами и переводами строк, символы не учитываются. Если подходящих последовательностей несколько, выведите любой из ответов.

Например, текст -- это задание, ключ -- “чек”, ответ -- 31

Текст представляет из себя .txt - файл размером до 2ГБ, а запросы и ответы на них должны вводиться/выводиться в консоль.

---

## Как использовать?
```C++
#include <cipher_finder.h>

int main() {
    std::string filename = ...;
    std::string key = ...;
    
    ...
    
    cipher::CipherFinder finder(std::move(filename));
    std::optional<size_t> result = finder.GetFirstKeyWord(key);  // <-- Тут мы получаем ответ к задаче
}

```

## Алгоритм

Нам заранее известен размер ключа, пусть это будет `KEY_SIZE`. Давайте будем хранить `KEY_SIZE` слов,
но не слова целиком, а лишь префиксы длины `KEY_SIZE`. Тогда мы проходимся по словам нашего текста, добавляя их в буффер
и сразу же убирая старые слова из буффера, и каждый раз проверяя на соответствие ключу.

Так как текст большой, то не будем его явно хранить. Мы знаем по условию задачи, что текст будет находится в файле, поэтому
передадим в конструктор класса название файла, и сразу же его откроем. Закрывать файл мы будем только тогда, когда экземпляр
класса уничтожится -- так нам не придется переоткрывать файл каждый раз, это очень дорогая операция. В итоге, объект
класса `std::fstream` будет выдавать нам слова. По хорошему, нужно было принимать первые пять символов в буффер,
а не просто принимать слова целиком, ибо они могуть быть большими, но я не успел это реализовать :)

Вообще говоря, можно было сделать класс шаблонным, а параметром шаблона сделать `input_iterator`, 
который можно было бы получить от `fstream`,
но я решил не делать класс шаблонным, так как это может доставить много головной боли, да и в задаче четко сказано. что
будет передача по файлу.

Программа не работает с кодировкой UTF-8. Это связано с тем, что работа с UTF-8 в C++ довольно сложна, и поэтому программа
работает в текстами в кодировке ASCII

Итого, по памяти асимптотика `O(max_size_of_word + key_size^2)`, по времени
`O(text_size)`

## Установка и тестирование
```
./build_and_install.sh && ./test.sh
```